.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Font::TTF::Silf 3"
.TH Font::TTF::Silf 3 "2012-05-18" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Font::TTF::Silf \- The main Graphite table
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Silf table holds the core of the Graphite rules for a font. A Silf table has
potentially multiple silf subtables, although there is usually only one. Within a silf subtable,
there are a number of passes which contain the actual finite state machines to match rules
and the constraint and action code to be executed when a rule matches.
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
.IP "Version" 4
.IX Item "Version"
Silf table format version
.IP "Compiler" 4
.IX Item "Compiler"
Lowest compiler version necessary to fully support the semantics expressed in this
Graphite description
.IP "\s-1SILF\s0" 4
.IX Item "SILF"
An array of Silf subtables
.RS 4
.IP "maxGlyphID" 4
.IX Item "maxGlyphID"
The maximum glyph id referenced including pseudo and non glyphs
.IP "Ascent" 4
.IX Item "Ascent"
Extra ascent to be added to the font ascent.
.IP "Descent" 4
.IX Item "Descent"
Extra descent to be added to the font descent. Both values are assumed to be
positive for a descender below the base line.
.IP "substPass" 4
.IX Item "substPass"
Pass index into \s-1PASS\s0 of the first substitution pass.
.IP "posPass" 4
.IX Item "posPass"
Pass index into \s-1PASS\s0 of the first positioning pass.
.IP "justPass" 4
.IX Item "justPass"
Pass index into \s-1PASS\s0 of the first justification pass.
.IP "bidiPass" 4
.IX Item "bidiPass"
Pass index of the pass before which the bidirectional processing pass will be executed.
0xFF indicates that there is no bidi pass to be executed.
.IP "Flags" 4
.IX Item "Flags"
A bitfield of flags:
.Sp
.Vb 1
\&    0 \- Indicates there are line end contextual rules in one of the passes
.Ve
.IP "maxPreContext" 4
.IX Item "maxPreContext"
Maximum length of a context preceding a cross line boundary contextualisation.
.IP "maxPostContext" 4
.IX Item "maxPostContext"
Maximum length of a context following a cross line boundary contextualsation.
.IP "attrPseudo" 4
.IX Item "attrPseudo"
Glyph attribute for the actual glyph id associated with a pseudo glyph.
.IP "attrBreakWeight" 4
.IX Item "attrBreakWeight"
Glyph attribute number of the attribute holding the default breakweight associated with a glyph.
.IP "attrDirectionality" 4
.IX Item "attrDirectionality"
Glyph attribute number of the attribute holding the default directionality value associated with a glyph.
.IP "\s-1JUST\s0" 4
.IX Item "JUST"
The may be a number of justification levels each with their own property values.
This points to an array of hashes, one for each justification level.
.RS 4
.IP "attrStretch" 4
.IX Item "attrStretch"
Glyph attribute number for the amount of stretch allowed before this glyph.
.IP "attrShrink" 4
.IX Item "attrShrink"
Glyph attribute number for the amount of shrink allowed before this glyph.
.IP "attrStep" 4
.IX Item "attrStep"
Glyph attribute number specifying the minimum granularity of actual spacing associated with this glyph at this level.
.IP "attrWeight" 4
.IX Item "attrWeight"
Glyph attribute number giving the weight associated with spreading space across a run of glyphs.
.IP "runto" 4
.IX Item "runto"
Which level starts the next stage.
.RE
.RS 4
.RE
.IP "numLigComp" 4
.IX Item "numLigComp"
Number of initial glyph attributes that represent ligature components
.IP "numUserAttr" 4
.IX Item "numUserAttr"
Number of user defined slot attributes referenced. Tells the engine how much space to
allocate to a slot for user attributes.
.IP "maxCompPerLig" 4
.IX Item "maxCompPerLig"
Maximum number of components per ligature.
.IP "direction" 4
.IX Item "direction"
Supported directions for this writing system
.IP "\s-1CRIT_FEATURE\s0" 4
.IX Item "CRIT_FEATURE"
Array of critical features.
.IP "scripts" 4
.IX Item "scripts"
Array of script tags that indicate which set of \s-1GDL\s0 rules to execute if there is more than one in a font.
.IP "lbGID" 4
.IX Item "lbGID"
Glyph \s-1ID\s0 of the linebreak pseudo glyph.
.IP "pseudos" 4
.IX Item "pseudos"
Hash of Unicode values to pseduo glyph ids.
.IP "classes" 4
.IX Item "classes"
This is an array of classes, each of which is an array of glyph ids in class order.
.IP "\s-1PASS\s0" 4
.IX Item "PASS"
The details of rules and actions are stored in passes. This value is an array of pass subobjects one for each pass.
.RS 4
.IP "flags" 4
.IX Item "flags"
This is a bitfield:
.Sp
.Vb 2
\&    0 \- If true, this pass makes no change to the slot stream considered as a sequence of glyph ids.
\&        Only slot attributes are expected to change (for example during positioning).
.Ve
.IP "maxRuleLoop" 4
.IX Item "maxRuleLoop"
How many times the engine will allow rules to be tested and run without the engine advancing through the
input slot stream.
.IP "maxRuleContext" 4
.IX Item "maxRuleContext"
Number of slots of input needed to run this pass.
.IP "maxBackup" 4
.IX Item "maxBackup"
Number of slots by which the following pass needs to trail this pass (i.e. the maximum this pass is allowed to back up).
.IP "numRules" 4
.IX Item "numRules"
Number of action code blocks, and so uncompressed rules, in this pass.
.IP "numRows" 4
.IX Item "numRows"
Number of rows in the finite state machine.
.IP "numTransitional" 4
.IX Item "numTransitional"
Number of rows in the finite state machine that are not final states. This specifies the number of rows in the fsm
element.
.IP "numSuccess" 4
.IX Item "numSuccess"
Number of success states. A success state may also be a transitional state.
.IP "numColumns" 4
.IX Item "numColumns"
Number of columns in the finite state machine.
.IP "colmap" 4
.IX Item "colmap"
A hash, indexed by glyphid, that gives the fsm column number associated with that glyphid. If not present, then
the glyphid is not part of the fsm and will finish fsm processing if it occurs.
.IP "rulemap" 4
.IX Item "rulemap"
An array of arrays, one for each success state. Each array holds a list of rule numbers associated with that state.
.IP "minRulePreContext" 4
.IX Item "minRulePreContext"
Minimum number of items in a rule's precontext.
.IP "maxRulePreContext" 4
.IX Item "maxRulePreContext"
The maximum number of items in any rule's precontext.
.IP "startStates" 4
.IX Item "startStates"
Array of starting state numbers dependeing on the length of actual precontext.
There are maxRulePreContext \- minRulePreContext + 1 of these.
.IP "ruleSortKeys" 4
.IX Item "ruleSortKeys"
An array of sort keys one for each rule giving the length of the rule without its precontext.
.IP "rulePreContexts" 4
.IX Item "rulePreContexts"
An array of precontext lengths for each rule.
.IP "fsm" 4
.IX Item "fsm"
A two dimensional array such that \f(CW$p\fR\->{'fsm'}[$row][$col] gives the row of the next node to try in the fsm.
.IP "passConstraintLen" 4
.IX Item "passConstraintLen"
Length in bytes of the passConstraint code.
.IP "passConstraintCode" 4
.IX Item "passConstraintCode"
A byte string holding the pass constraint code.
.IP "constraintCode" 4
.IX Item "constraintCode"
An array of byte strings holding the constraint code for each rule.
.IP "actionCode" 4
.IX Item "actionCode"
An array of byte strings holding the action code for each rule.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .Sh "@opcodes"
.el .Sh "\f(CW@opcodes\fP"
.IX Subsection "@opcodes"
Each array holds the name of the opcode, the number of operand bytes and a string describing the operands.
The characterse in the string have the following meaning:
.PP
.Vb 10
\&    c \- lsb of class id
\&    C \- msb of class id
\&    f \- feature index
\&    g \- lsb of glyph attribute id
\&    G \- msb of glyph attribute id
\&    l \- lsb of a 32\-bit extension to a 16\-bit number
\&    L \- msb of a 32\-bit number
\&    m \- glyph metric id
\&    n \- lsb of a number
\&    N \- msb of a 16\-bit number
\&    o \- offset (jump)
\&    s \- slot reference
\&    S \- slot attribute id
\&    v \- variable number of following arguments
.Ve
.Sh "read"
.IX Subsection "read"
Reads the Silf table into the internal data structure
.Sh "out"
.IX Subsection "out"
Outputs a Silf data structure to a font file in binary format
