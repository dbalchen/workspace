.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Schedule::Cron 3"
.TH Schedule::Cron 3 "2011-06-06" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Cron \- cron\-like scheduler for Perl subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Schedule::Cron;
\&
\&  # Subroutines to be called
\&  sub dispatcher { 
\&    print "ID:   ",shift,"\en"; 
\&    print "Args: ","@_","\en";
\&  }
\&
\&  sub check_links { 
\&    # do something... 
\&  }
\&
\&  # Create new object with default dispatcher
\&  my $cron = new Schedule::Cron(\e&dispatcher);
\&
\&  # Load a crontab file
\&  $cron\->load_crontab("/var/spool/cron/perl");
\&
\&  # Add dynamically  crontab entries
\&  $cron\->add_entry("3 4  * * *",ROTATE => "apache","sendmail");
\&  $cron\->add_entry("0 11 * * Mon\-Fri",\e&check_links);
\&
\&  # Run scheduler 
\&  $cron\->run(detach=>1);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a simple but complete cron like scheduler.  I.e this
module can be used for periodically executing Perl subroutines.  The dates and
parameters for the subroutines to be called are specified with a format known
as crontab entry (see \*(L"\s-1METHODS\s0\*(R", \f(CW\*(C`add_entry()\*(C'\fR and \fIcrontab\fR\|(5))
.PP
The philosophy behind \f(CW\*(C`Schedule::Cron\*(C'\fR is to call subroutines periodically
from within one single Perl program instead of letting \f(CW\*(C`cron\*(C'\fR trigger several
(possibly different) Perl scripts. Everything under one roof.  Furthermore,
\&\f(CW\*(C`Schedule::Cron\*(C'\fR provides mechanism to create crontab entries dynamically,
which isn't that easy with \f(CW\*(C`cron\*(C'\fR.
.PP
\&\f(CW\*(C`Schedule::Cron\*(C'\fR knows about all extensions (well, at least all extensions I'm
aware of, i.e those of the so called \*(L"Vixie\*(R" cron) for crontab entries like
ranges including 'steps', specification of month and days of the week by name,
or coexistence of lists and ranges in the same field.  It even supports a bit
more (like lists and ranges with symbolic names).
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$cron = new Schedule::Cron($dispatcher,[extra args])" 4
.el .IP "\f(CW$cron\fR = new Schedule::Cron($dispatcher,[extra args])" 4
.IX Item "$cron = new Schedule::Cron($dispatcher,[extra args])"
Creates a new \f(CW\*(C`Cron\*(C'\fR object.  \f(CW$dispatcher\fR is a reference to a subroutine,
which will be called by default.  \f(CW$dispatcher\fR will be invoked with the
arguments parameter provided in the crontab entry if no other subroutine is
specified. This can be either a single argument containing the argument
parameter literally has string (default behavior) or a list of arguments when
using the \f(CW\*(C`eval\*(C'\fR option described below.
.Sp
The date specifications must be either provided via a crontab like file or
added explicitly with \f(CW\*(C`add_entry()\*(C'\fR (\*(L"add_entry\*(R").
.Sp
\&\fIextra_args\fR can be a hash or hash reference for additional arguments.  The
following parameters are recognized:
.RS 4
.IP "file => <crontab>" 4
.IX Item "file => <crontab>"
Load the crontab entries from <crontab>
.IP "eval =>  1" 4
.IX Item "eval =>  1"
Eval the argument parameter in a crontab entry before calling the subroutine
(instead of literally calling the dispatcher with the argument parameter as
string)
.IP "nofork => 1" 4
.IX Item "nofork => 1"
Don't fork when starting the scheduler. Instead, the jobs are executed within
current process. In your executed jobs, you have full access to the global
variables of your script and hence might influence other jobs running at a
different time. This behaviour is fundamentally different to the 'fork' mode,
where each jobs gets its own process and hence a \fBcopy\fR of the process space,
independent of each other job and the main process. This is due to the nature
of the  \f(CW\*(C`fork\*(C'\fR system call.
.IP "nostatus =>  1" 4
.IX Item "nostatus =>  1"
Do not update status in \f(CW$0\fR.  Set this if you don't want ps to reveal the internals
of your application, including job argument lists.  Default is 0 (update status).
.IP "skip => 1" 4
.IX Item "skip => 1"
Skip any pending jobs whose time has passed. This option is only useful in
combination with \f(CW\*(C`nofork\*(C'\fR where a job might block the execution of the
following jobs for quite some time. By default, any pending job is executed
even if its scheduled execution time has already passed. With this option set
to true all pending which would have been started in the meantime are skipped.
.IP "catch => 1" 4
.IX Item "catch => 1"
Catch any exception raised by a job. This is especially useful in combination with
the \f(CW\*(C`nofork\*(C'\fR option to avoid stopping the main process when a job raises an
exception (dies).
.IP "after_job => \e&after_sub" 4
.IX Item "after_job => &after_sub"
Call a subroutine after a job has been run. The first argument is the return
value of the dispatched job, the reminding arguments are the arguments with
which the dispatched job has been called.
.Sp
Example:
.Sp
.Vb 4
\&   my $cron = new Schedule::Cron(..., after_job => sub {
\&          my ($ret,@args) = @_;
\&          print "Return value: ",$ret," \- job arguments: (",join ":",@args,")\en";
\&   });
.Ve
.IP "log => \e&log_sub" 4
.IX Item "log => &log_sub"
Install a logging subroutine. The given subroutine is called for several events
during the lifetime of a job. This method is called with two arguments: A log
level of 0 (info),1 (warning) or 2 (error) depending on the importance of the
message and the message itself.
.Sp
For example, you could use \fILog4perl\fR (<http://log4perl.sf.net>) for logging
purposes for example like in the following code snippet:
.Sp
.Vb 2
\&   use Log::Log4perl;
\&   use Log::Log4perl::Level;
\&
\&   my $log_method = sub {
\&      my ($level,$msg) = @_;
\&      my $DBG_MAP = { 0 => $INFO, 1 => $WARN, 2 => $ERROR };
\&
\&      my $logger = Log::Log4perl\->get_logger("My::Package");
\&      $logger\->log($DBG_MAP\->{$level},$msg);
\&   }
\&  
\&   my $cron = new Schedule::Cron(.... , log => $log_method);
.Ve
.IP "loglevel => <\-1,0,1,2>" 4
.IX Item "loglevel => <-1,0,1,2>"
Restricts logging to the specified severity level or below.  Use 0 to have all
messages generated, 1 for only warnings and errors and 2 for errors only.
Default is 0 (all messages).  A loglevel of \-1 (debug) will include job
argument lists (also in \f(CW$0\fR) in the job start message logged with a level of 0
or above. You may have security concerns with this. Unless you are debugging,
use 0 or higher. A value larger than 2 will disable logging completely.
.Sp
Although you can filter in your log routine, generating the messages can be
expensive, for example if you pass arguments pointing to large hashes.  Specifying
a loglevel avoids formatting data that your routine would discard.
.IP "processprefix => <name>" 4
.IX Item "processprefix => <name>"
Cron::Schedule sets the process' name (i.e. \f(CW$0\fR) to contain some informative
messages like when the next job executes or with which arguments a job is
called. By default, the prefix for this labels is \f(CW\*(C`Schedule::Cron\*(C'\fR. With this
option you can set it to something different. You can e.g. use \f(CW$0\fR to include
the original process name.  You can inhibit this with the \f(CW\*(C`nostatus\*(C'\fR option, and
prevent the argument display by setting \f(CW\*(C`loglevel\*(C'\fR to zero or higher.
.IP "sleep => \e&hook" 4
.IX Item "sleep => &hook"
If specified, &hook will be called instead of \fIsleep()\fR, with the time to sleep
in seconds as first argument and the Schedule::Cron object as second.  This hook
allows you to use \fIselect()\fR instead of sleep, so that you can handle \s-1IO\s0, for
example job requests from a network connection.
.Sp
e.g.
.Sp
.Vb 1
\&  $cron\->run( { sleep => \e&sleep_hook, nofork => 1 } );
\&
\&  sub sleep_hook {
\&    my ($time, $cron) = @_;
\&
\&    my ($rin, $win, $ein) = (\*(Aq\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq);
\&    my ($rout, $wout, $eout);
\&    vec($rin, fileno(STDIN), 1) = 1;
\&    my ($nfound, $ttg) = select($rout=$rin, $wout=$win, $eout=$ein, $time);
\&    if ($nfound) {
\&           handle_io($rout, $wout, $eout);
\&    }
\&    return;
\&}
.Ve
.RE
.RS 4
.RE
.ie n .IP "$cron\->load_crontab($file)" 4
.el .IP "\f(CW$cron\fR\->load_crontab($file)" 4
.IX Item "$cron->load_crontab($file)"
.PD 0
.ie n .IP "$cron\->load_crontab(file=>$file,[eval=>1])" 4
.el .IP "\f(CW$cron\fR\->load_crontab(file=>$file,[eval=>1])" 4
.IX Item "$cron->load_crontab(file=>$file,[eval=>1])"
.PD
Loads and parses the crontab file \f(CW$file\fR. The entries found in this file will
be \fBadded\fR to the current time table with \f(CW\*(C`$cron\->add_entry\*(C'\fR.
.Sp
The format of the file consists of cron commands containing of lines with at
least 5 columns, whereas the first 5 columns specify the date.  The rest of the
line (i.e columns 6 and greater) contains the argument with which the
dispatcher subroutine will be called.  By default, the dispatcher will be
called with one single string argument containing the rest of the line
literally.  Alternatively, if you call this method with the optional argument
\&\f(CW\*(C`eval=>1\*(C'\fR (you must then use the second format shown above), the rest of
the line will be evaled before used as argument for the dispatcher.
.Sp
For the format of the first 5 columns, please see \*(L"add_entry\*(R".
.Sp
Blank lines and lines starting with a \f(CW\*(C`#\*(C'\fR will be ignored.
.Sp
There's no way to specify another subroutine within the crontab file.  All
calls will be made to the dispatcher provided at construction time.
.Sp
If    you   want    to    start   up    fresh,    you   should    call
\&\f(CW\*(C`$cron\->clean_timetable()\*(C'\fR before.
.Sp
Example of a crontab fiqw(le:)
.Sp
.Vb 4
\&   # The following line runs on every Monday at 2:34 am
\&   34 2 * * Mon  "make_stats"
\&   # The next line should be best read in with an eval=>1 argument
\&   *  * 1 1 *    { NEW_YEAR => \*(Aq1\*(Aq,HEADACHE => \*(Aqon\*(Aq }
.Ve
.ie n .IP "$cron\->add_entry($timespec,[arguments])" 4
.el .IP "\f(CW$cron\fR\->add_entry($timespec,[arguments])" 4
.IX Item "$cron->add_entry($timespec,[arguments])"
Adds a new entry to the list of scheduled cron jobs.
.Sp
\&\fBTime and Date specification\fR
.Sp
\&\f(CW$timespec\fR is the specification of the scheduled time in crontab format
(\fIcrontab\fR\|(5)) which contains five mandatory time and date fields and an
optional 6th column. \f(CW$timespec\fR can be either a plain string, which contains
a whitespace separated time and date specification.  Alternatively,
\&\f(CW$timespec\fR can be a reference to an array containing the five elements for
the date fields.
.Sp
The time and date fields are (taken mostly from \fIcrontab\fR\|(5), \*(L"Vixie\*(R" cron):
.Sp
.Vb 8
\&   field          values
\&   =====          ======
\&   minute         0\-59
\&   hour           0\-23
\&   day of month   1\-31 
\&   month          1\-12 (or as names)
\&   day of week    0\-7 (0 or 7 is Sunday, or as names)
\&   seconds        0\-59 (optional)
\&
\& A field may be an asterisk (*), which always stands for
\& \`\`first\-last\*(Aq\*(Aq.
\&
\& Ranges of numbers are  allowed.  Ranges are two numbers
\& separated  with  a  hyphen.   The  specified  range  is
\& inclusive.   For example, 8\-11  for an  \`\`hours\*(Aq\*(Aq entry
\& specifies execution at hours 8, 9, 10 and 11.
\&
\& Lists  are allowed.   A list  is a  set of  numbers (or
\& ranges)  separated by  commas.   Examples: \`\`1,2,5,9\*(Aq\*(Aq,
\& \`\`0\-4,8\-12\*(Aq\*(Aq.
\&
\& Step  values can  be used  in conjunction  with ranges.
\& Following a range with \`\`/<number>\*(Aq\*(Aq specifies skips of
\& the  numbers value  through the  range.   For example,
\& \`\`0\-23/2\*(Aq\*(Aq can  be used in  the hours field  to specify
\& command execution every  other hour (the alternative in
\& the V7 standard is \`\`0,2,4,6,8,10,12,14,16,18,20,22\*(Aq\*(Aq).
\& Steps are  also permitted after an asterisk,  so if you
\& want to say \`\`every two hours\*(Aq\*(Aq, just use \`\`*/2\*(Aq\*(Aq.
\&
\& Names can also  be used for the \`\`month\*(Aq\*(Aq  and \`\`day of
\& week\*(Aq\*(Aq  fields.  Use  the  first three  letters of  the
\& particular day or month (case doesn\*(Aqt matter).
\&
\& Note: The day of a command\*(Aqs execution can be specified
\&       by two fields  \-\- day of month, and  day of week.
\&       If both fields are restricted (ie, aren\*(Aqt *), the
\&       command will be run when either field matches the
\&       current  time.  For  example, \`\`30  4 1,15  * 5\*(Aq\*(Aq
\&       would cause a command to be run at 4:30 am on the
\&       1st and 15th of each month, plus every Friday
.Ve
.Sp
Examples:
.Sp
.Vb 7
\& "8  0 * * *"         ==> 8 minutes after midnight, every day
\& "5 11 * * Sat,Sun"   ==> at 11:05 on each Saturday and Sunday
\& "0\-59/5 * * * *"     ==> every five minutes
\& "42 12 3 Feb Sat"    ==> at 12:42 on 3rd of February and on 
\&                          each Saturday in February
\& "32 11 * * * 0\-30/2" ==> 11:32:00, 11:32:02, ... 11:32:30 every 
\&                          day
.Ve
.Sp
In addition, ranges or lists of names are allowed.
.Sp
An optional sixth column can be used to specify the seconds within the
minute. If not present, it is implicitely set to \*(L"0\*(R".
.Sp
\&\fBCommand specification\fR
.Sp
The subroutine to be executed when the the \f(CW$timespec\fR matches can be
specified in several ways.
.Sp
First, if the optional \f(CW\*(C`arguments\*(C'\fR are lacking, the default dispatching
subroutine provided at construction time will be called without arguments.
.Sp
If the second parameter to this method is a reference to a subroutine, this
subroutine will be used instead of the dispatcher.
.Sp
Any additional parameters will be given as arguments to the subroutine to be
executed.  You can also specify a reference to an array instead of a list of
parameters.
.Sp
You can also use a named parameter list provided as an hashref.  The named
parameters recognized are:
.RS 4
.IP "subroutine" 4
.IX Item "subroutine"
.PD 0
.IP "sub" 4
.IX Item "sub"
.PD
Reference to subroutine to be executed
.IP "arguments" 4
.IX Item "arguments"
.PD 0
.IP "args" 4
.IX Item "args"
.PD
Reference to array containing arguments to be use when calling the subroutine
.IP "eval" 4
.IX Item "eval"
If true, use the evaled string provided with the \f(CW\*(C`arguments\*(C'\fR parameter.  The
evaluation will take place immediately (not when the subroutine is going to be
called)
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 8
\&   $cron\->add_entry("* * * * *");
\&   $cron\->add_entry("* * * * *","doit");
\&   $cron\->add_entry("* * * * *",\e&dispatch,"first",2,"third");
\&   $cron\->add_entry("* * * * *",{\*(Aqsubroutine\*(Aq => \e&dispatch,
\&                                 \*(Aqarguments\*(Aq  => [ "first",2,"third" ]});
\&   $cron\->add_entry("* * * * *",{\*(Aqsubroutine\*(Aq => \e&dispatch,
\&                                 \*(Aqarguments\*(Aq  => \*(Aq[ "first",2,"third" ]\*(Aq,
\&                                 \*(Aqeval\*(Aq       => 1});
.Ve
.RE
.ie n .IP "@entries\fR = \f(CW$cron\fR\->\fIlist_entries()" 4
.el .IP "\f(CW@entries\fR = \f(CW$cron\fR\->\fIlist_entries()\fR" 4
.IX Item "@entries = $cron->list_entries()"
Return a list of cron entries. Each entry is a hash reference of the following
form:
.Sp
.Vb 5
\&  $entry = { 
\&             time => $timespec,
\&             dispatch => $dispatcher,
\&             args => $args_ref
\&           }
.Ve
.Sp
Here \f(CW$timespec\fR is the specified time in crontab format as provided to
\&\f(CW\*(C`add_entry\*(C'\fR, \f(CW$dispatcher\fR is a reference to the dispatcher for this entry
and \f(CW$args_ref\fR is a reference to an array holding additional arguments (which
can be an empty array reference). For further explanation of this arguments
refer to the documentation of the method \f(CW\*(C`add_entry\*(C'\fR.
.Sp
The order index of each entry can be used within \f(CW\*(C`update_entry\*(C'\fR, \f(CW\*(C`get_entry\*(C'\fR
and \f(CW\*(C`delete_entry\*(C'\fR. But be aware, when you are deleting an entry, that you
have to refetch the list, since the order will have changed.
.Sp
Note that these entries are returned by value and were opbtained from the
internal list by a deep copy. I.e. you are free to modify it, but this won't
influence the original entries. Instead use \f(CW\*(C`update_entry\*(C'\fR if you need to
modify an exisiting crontab entry.
.ie n .IP "$entry\fR = \f(CW$cron\->get_entry($idx)" 4
.el .IP "\f(CW$entry\fR = \f(CW$cron\fR\->get_entry($idx)" 4
.IX Item "$entry = $cron->get_entry($idx)"
Get a single entry. \f(CW$entry\fR is either a hashref with the possible keys
\&\f(CW\*(C`time\*(C'\fR, \f(CW\*(C`dispatch\*(C'\fR and \f(CW\*(C`args\*(C'\fR (see \f(CW\*(C`list_entries()\*(C'\fR) or undef if no entry
with the given index \f(CW$idx\fR exists.
.ie n .IP "$cron\->delete_entry($idx)" 4
.el .IP "\f(CW$cron\fR\->delete_entry($idx)" 4
.IX Item "$cron->delete_entry($idx)"
Delete the entry at index \f(CW$idx\fR. Returns the deleted entry on success,
\&\f(CW\*(C`undef\*(C'\fR otherwise.
.ie n .IP "$cron\->update_entry($idx,$entry)" 4
.el .IP "\f(CW$cron\fR\->update_entry($idx,$entry)" 4
.IX Item "$cron->update_entry($idx,$entry)"
Updates the entry with index \f(CW$idx\fR. \f(CW$entry\fR is a hash ref as descibed in
\&\f(CW\*(C`list_entries()\*(C'\fR and must contain at least a value \f(CW\*(C`$entry\->{time}\*(C'\fR. If no
\&\f(CW\*(C`$entry\->{dispatcher}\*(C'\fR is given, then the default dispatcher is used.  This
method returns the old entry on success, \f(CW\*(C`undef\*(C'\fR otherwise.
.ie n .IP "$cron\->run([options])" 4
.el .IP "\f(CW$cron\fR\->run([options])" 4
.IX Item "$cron->run([options])"
This method starts the scheduler.
.Sp
When called without options, this method will never return and executes the
scheduled subroutine calls as needed.
.Sp
Alternatively, you can detach the main scheduler loop from the current process
(daemon mode). In this case, the pid of the forked scheduler process will be
returned.
.Sp
The \f(CW\*(C`options\*(C'\fR parameter specifies the running mode of \f(CW\*(C`Schedule::Cron\*(C'\fR.  It
can be either a plain list which will be interpreted as a hash or it can be a
reference to a hash. The following named parameters (keys of the provided hash)
are recognized:
.RS 4
.IP "detach" 4
.IX Item "detach"
If set to a true value the scheduler process is detached from the current
process (\s-1UNIX\s0 only).
.IP "pid_file" 4
.IX Item "pid_file"
If running in daemon mode, name the optional file, in which the process id of
the scheduler process should be written. By default, no \s-1PID\s0 File will be
created.
.IP "nofork, skip, catch, log, loglevel, nostatus, sleep" 4
.IX Item "nofork, skip, catch, log, loglevel, nostatus, sleep"
See \f(CW\*(C`new()\*(C'\fR for a description of these configuration parameters, which can be
provided here as well. Note, that the options given here overrides those of the
constructor.
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 4
\&   # Start  scheduler, detach  from current  process and
\&   # write  the  PID  of  the forked  scheduler  to  the
\&   # specified file
\&   $cron\->run(detach=>1,pid_file=>"/var/run/scheduler.pid");
\&
\&   # Start scheduler and wait forever.
\&   $cron\->run();
.Ve
.RE
.ie n .IP "$cron\fR\->\fIclean_timetable()" 4
.el .IP "\f(CW$cron\fR\->\fIclean_timetable()\fR" 4
.IX Item "$cron->clean_timetable()"
Remove all scheduled entries
.ie n .IP "$cron\->check_entry($id)" 4
.el .IP "\f(CW$cron\fR\->check_entry($id)" 4
.IX Item "$cron->check_entry($id)"
Check, whether the given \s-1ID\s0 is already registered in the timetable. 
A \s-1ID\s0 is the first argument in the argument parameter of the 
a crontab entry.
.Sp
Returns (one of) the index in the  timetable (can be 0, too) if the \s-1ID\s0
could be found or \f(CW\*(C`undef\*(C'\fR otherwise.
.Sp
Example:
.Sp
.Vb 4
\&   $cron\->add_entry("* * * * *","ROTATE");
\&   .
\&   .
\&   defined($cron\->check_entry("ROTATE")) || die "No ROTATE entry !"
.Ve
.ie n .IP "$cron\->get_next_execution_time($cron_entry,[$ref_time])" 4
.el .IP "\f(CW$cron\fR\->get_next_execution_time($cron_entry,[$ref_time])" 4
.IX Item "$cron->get_next_execution_time($cron_entry,[$ref_time])"
Well, this is mostly an internal method, but it might be useful on 
its own.
.Sp
The purpose of this method is to calculate the next execution time
from a specified crontab entry
.Sp
Parameters:
.RS 4
.ie n .IP "$cron_entry" 4
.el .IP "\f(CW$cron_entry\fR" 4
.IX Item "$cron_entry"
The crontab entry as specified in \*(L"add_entry\*(R"
.ie n .IP "$ref_time" 4
.el .IP "\f(CW$ref_time\fR" 4
.IX Item "$ref_time"
The reference time for which the next time should be searched which matches
\&\f(CW$cron_entry\fR. By default, take the current time
.RE
.RS 4
.Sp
This method returns the number of epoch-seconds of the next matched 
date for \f(CW$cron_entry\fR.
.Sp
Since I suspect, that this calculation of the next execution time might
fail in some circumstances (bugs are lurking everywhere ;\-) an
additional interactive method \f(CW\*(C`bug()\*(C'\fR is provided for checking
crontab entries against your expected output. Refer to the
top-level \s-1README\s0 for additional usage information for this method.
.RE
.SH "DST ISSUES"
.IX Header "DST ISSUES"
Daylight saving occurs typically twice a year: In the first switch, one hour is
skipped. Any job which which triggers in this skipped hour will be fired in the
next hour. So, when the \s-1DST\s0 switch goes from 2:00 to 3:00 a job which is
scheduled for 2:43 will be executed at 3:43.
.PP
For the reverse backwards switch later in the year, the behaviour is
undefined. Two possible behaviours can occur: For jobs triggered in short
intervals, where the next execution time would fire in the extra hour as well,
the job could be executed again or skipped in this extra hour. Currently,
running \f(CW\*(C`Schedule::Cron\*(C'\fR in \f(CW\*(C`MET\*(C'\fR would skip the extra job, in \f(CW\*(C`PST8PDT\*(C'\fR it
would execute a second time. The reason is the way how Time::ParseDate
calculates epoch times for dates given like \f(CW\*(C`02:50:00 2009/10/25\*(C'\fR. Should it
return the seconds since 1970 for this time happening 'first', or for this time
in the extra hour ? As it turns out, Time::ParseDate returns the epoch time
of the first occurence for \f(CW\*(C`PST8PDT\*(C'\fR and for \f(CW\*(C`MET\*(C'\fR it returns the second
occurence. Unfortunately, there is no way to specify \fIwhich\fR entry
Time::ParseDate should pick (until now). Of course, after all, this is
obviously not Time::ParseDate's fault, since a simple date specification
within the \s-1DST\s0 backswitch period \fBis\fR ambigious. However, it would be nice if
the parsing behaviour of Time::ParseDate would be consistent across time
zones (a ticket has be raised for fixing this). Then Schedule::Cron's
behaviour within a \s-1DST\s0 backward switch would be consistent as well.
.PP
Since changing the internal algorithm which worked now for over ten years would
be too risky and I don't see any simple solution for this right now, it is
likely that this \fIundefined\fR behaviour will exist for some time. Maybe some
hero is coming along and will fix this, but this is probably not me ;\-)
.PP
Sorry for that.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 1999\-2011 Roland Huss.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&... roland
