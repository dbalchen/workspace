.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Font::TTF::GDEF 3"
.TH Font::TTF::GDEF 3 "2012-08-08" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Font::TTF::GDEF \- Opentype GDEF table support
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1GDEF\s0 table contains various global lists of information which are apparantly
used in other places in an OpenType renderer. But precisely where is open to
speculation...
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
There are up to 5 tables in the \s-1GDEF\s0 table, each with their own structure:
.IP "\s-1GLYPH\s0" 4
.IX Item "GLYPH"
This is an Font::TTF::Coverage Class Definition table containing information
as to what type each glyph is.
.IP "\s-1ATTACH\s0" 4
.IX Item "ATTACH"
The attach table consists of a coverage table and then attachment points for
each glyph in the coverage table:
.RS 4
.IP "\s-1COVERAGE\s0" 8
.IX Item "COVERAGE"
This is a coverage table
.IP "\s-1POINTS\s0" 8
.IX Item "POINTS"
This is an array of point elements. Each element is an array of curve points
corresponding to the attachment points on that glyph. The order of the curve points
in the array corresponds to the attachment point number specified in the \s-1MARKS\s0
coverage table (see below).
.RE
.RS 4
.RE
.IP "\s-1LIG\s0" 4
.IX Item "LIG"
This contains the ligature caret positioning information for ligature glyphs
.RS 4
.IP "\s-1COVERAGE\s0" 8
.IX Item "COVERAGE"
A coverage table to say which glyphs are ligatures
.IP "\s-1LIGS\s0" 8
.IX Item "LIGS"
An array of elements for each ligature. Each element is an array of information
for each caret position in the ligature (there being number of components \- 1 of
these, generally)
.RS 8
.IP "\s-1FMT\s0" 12
.IX Item "FMT"
This is the format of the information and is important to provide the semantics
for the value. This value must be set correctly before output
.IP "\s-1VAL\s0" 12
.IX Item "VAL"
The value which has meaning according to \s-1FMT\s0
.IP "\s-1DEVICE\s0" 12
.IX Item "DEVICE"
For \s-1FMT\s0 = 3, a device table is also referenced which is stored here
.RE
.RS 8
.RE
.RE
.RS 4
.RE
.IP "\s-1MARKS\s0" 4
.IX Item "MARKS"
This class definition table defines the classes of mark glyphs that can be selected
for processing using the MarkAttachmentType field of lookup \s-1FLAG\s0 words.
.IP "\s-1MARKSETS\s0" 4
.IX Item "MARKSETS"
Contains an array of coverage tables indexed by the \s-1FILTER\s0 value of a lookup.
.SH "METHODS"
.IX Header "METHODS"
.ie n .Sh "$t\->read"
.el .Sh "\f(CW$t\fP\->read"
.IX Subsection "$t->read"
Reads the table into the data structure
.ie n .Sh "$t\->out($fh)"
.el .Sh "\f(CW$t\fP\->out($fh)"
.IX Subsection "$t->out($fh)"
Writes out this table.
.ie n .Sh "$t\->update"
.el .Sh "\f(CW$t\fP\->update"
.IX Subsection "$t->update"
Sort \s-1COVERAGE\s0 tables.
